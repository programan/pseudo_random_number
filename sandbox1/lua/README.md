Lua study
===

Lua
---

* Lua5.1にはbit演算が無いのでライブラリを使う
    * http://lua.tips/index.php?Lua%20implements_func_bit32
* Lua5.2にはbit演算が追加されている(bit32)
* Lua5.3ではbit32が廃止され、<< >>の演算子追加されている
* Lua5.2までは整数型が存在しない


Luaの数値
---

* Luaでは変数に数値をできる
* しかし、型としては数値を扱うための「数値型」という型がひとつあるのみ
    * 整数型や浮動小数点型というもの存在しない
* 実態はC言語のdouble(倍精度浮動小数)
* 整数でも浮動小数点でも、すべて数値型の値として同じこの数値型に(C言語のdouble型として)格納される


### C言語のdouble型

* 8byte
    * 64bit
	* 今のVCだと9byteかも
* 内部表現(64ビット長)
    * 先頭1ビットが符号
	* 次の11ビットが指数部
	* 残りの52ビットが仮数部

#### doubleの精度

* 仮数部が52なので0から52の53通り
* つまり2の53乗が精度
* 2^53 = 9007199254740992 = 9 * 10^15
    * 15、16桁くらい


### Luaでの整数

* Luaで32ビットの整数は完全に表現できる
    * 53ビット分の精度があるので、32ビットのint型としての役割りを果たせる


### Luaでの乱数

* RubyやPythonでは基本的に数値は整数と少数と別の型
* また格納できるサイズも大きい
    * 32ビットや64ビットを超える値は自動的に多倍長整数型に切り替わる
	* なのでC言語のように、例えば32ビットを超える値の場合はオーバーフローして切り捨てられることは無くても、
	自分で2の32乗の剰余を取ることで32ビット以内に丸めることで、ある範囲の中での乱数を生成できる
* しかしLuaの場合は全てがdoubleなので、乱数を計算する仮定で15桁をオーバーしてしまうと適当に丸められてしまう
* つまり計算が狂い他の言語で同じアルゴリズムで組んだ乱数生成処理と同じ結果にならない
* これが整数型であればC言語と同じようにRND_MAX(=0x7fff)という16ビットの範囲で最終的に収める処理も出来るが、doubleだと厳しい









