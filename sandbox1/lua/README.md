Lua study
===

Lua
---

* Lua5.1にはbit演算が無いのでライブラリを使う
    * http://lua.tips/index.php?Lua%20implements_func_bit32
* Lua5.2にはbit演算が追加されている(bit32)
* Lua5.3ではbit32が廃止され、<< >>の演算子追加されている
* Lua5.2までは整数型が存在しない


Luaの数値
---

* Luaでは変数に数値をできる
* しかし、型としては数値を扱うための「数値型」という型がひとつあるのみ
    * 整数型や浮動小数点型というもの存在しない
* 実態はC言語のdouble(倍精度浮動小数)
* 整数でも浮動小数点でも、すべて数値型の値として同じこの数値型に(C言語のdouble型として)格納される


### C言語のdouble型

* 8byte
    * 64bit
	* 今のVCだと9byteかも
* 内部表現(64ビット長)
    * 先頭1ビットが符号
	* 次の11ビットが指数部
	* 残りの52ビットが仮数部
	* `|0|000 0000 0000|0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000|`

#### doubleの精度

* 仮数部が52なので0から52の53通り
* つまり2の53乗が精度
* 2^53 = 9007199254740992 = 9 * 10^15
    * 15、16桁くらい
* long long型も64bit
    * 2^64 = 18446744073709551616
	* -9223372036854775808から9223372036854775807まで
	* 19桁
	* 指数、仮数と分割されているdoubleとは違い、64bit全て使える
* long longの9223372036854775807(19桁)をdoubleにキャストすると、9.2233720368547758E+18となる
* 後ろの07が失われて00になってしまう
* 数としての大きさ(桁)は保つが下の方の桁が0になってしまい情報が失われる



### Luaでの整数

* Luaで32ビットの整数は完全に表現できる
    * 53ビット分の精度があるので、32ビットのint型としての役割りを果たせる


### Luaでの乱数

* RubyやPythonでは基本的に数値は整数と少数で別の型
* また格納できるサイズも大きい
    * 32ビットや64ビットを超える値は自動的に多倍長整数型に切り替わる
	* C言語のように、例えば32ビットを超える値の場合はオーバーフローして切り捨てられることは無い
	* 自分で2の32乗の剰余を取ることで32ビット以内に収めることで、ある範囲の中での乱数を生成できる
* しかしLuaの場合は全てがdoubleなので、乱数を計算する仮定で15桁をオーバーしてしまうと適当に丸められてしまう
* つまり計算が狂い他の言語で同じアルゴリズムで組んだ乱数生成処理と同じ結果にならない
    * C言語だと32bitを超えれば切り捨てられ、BigIntをサポートする言語ではまず正しい計算をしてから自分で切り捨てることができる
	* doubleだと仮数部の2^53の長さを超ても上手く誤魔化して計算をしてしまう
	* つまり情報が失われてしまう
* Luaで線形合同法を用いて他の言語と同じ結果を返す乱数を作るのは難しいかもしれない






